<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squad Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark mode background */
            color: #e2e8f0;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        body.light-mode {
            background-color: #f0f4f8;
            color: #6b7280;
        }
        .kpi-card {
            background-color: #F29F05;
            color: white;
        }
        .kpi-number {
            font-weight: 900;
            font-size: 4rem;
            line-height: 1;
        }
        
        /* Toggle Switch Styling - (Adapted from stylesheet.txt) */
        .toggle-switch {
            position: absolute;
            top: 5px;
            left: 20px;
            z-index: 10;
        }
        .toggle-switch input[type="checkbox"] {
            height: 0;
            width: 0;
            visibility: hidden;
        }
        .toggle-switch label {
            cursor: pointer;
            text-indent: -9999px;
            width: 60px;
            height: 30px;
            background: #4a5568;
            display: block;
            border-radius: 100px;
            position: relative;
        }
        body.light-mode .toggle-switch label {
            background: #cbd5e0;
        }
        .toggle-switch label:after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 90px;
            transition: 0.3s;
        }
        .toggle-switch input:checked + label {
            background: #00A6A6;
        }
        .toggle-switch input:checked + label:after {
            left: calc(100% - 3px);
            transform: translateX(-100%);
        }
        .toggle-switch .sun-icon { right: 8px; color: #cbd5e0; }
        .toggle-switch .moon-icon { left: 8px; color: #fff; }
        body.light-mode .toggle-switch .sun-icon { color: #fff; }
        body.light-mode .toggle-switch .moon-icon { color: #4a5568; }

        /* Custom Role Colors - Text colors for light backgrounds */
        .role-aoe-dps { background-color: #8FBC8F; /* Sickly Green */ }
        
        /* Healer column: Light Blue, Black Text */
        .role-healer { background-color: #ADD8E6; /* Light Blue */ color: #1a202c; } 
        
        /* Boon Support column: Light Pink, Black Text */
        .role-boon-support { background-color: #FFB6C1; /* Light Pink */ color: #1a202c; } 
        
        .role-dps { background-color: #F08080; /* Light Red */ }
        
        /* Main Stabs column: Light Yellow, Black Text */
        .role-main-stabs { background-color: #FFFFE0; /* Light Yellow */ color: #1a202c; } 
        
        .role-commander { background-color: #F29F05; /* Commander Color */ }
        .role-empty { 
            background-color: #4a5568; /* Darker grey for empty slots */ 
        }
        /* Style for editable cells when focused */
        [contenteditable]:focus {
            outline: 2px solid #F29F05; /* Commander/KPI color for focus */
            background-color: #3b4252; /* Slightly lighter grey when focused */
        }
        /* Style for drag and drop */
        td[draggable="true"] {
            cursor: grab;
        }
        td[draggable="true"]:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="p-6 min-h-screen">

    <div class="toggle-switch">
        <input type="checkbox" id="theme-toggle" onchange="toggleTheme()">
        <label for="theme-toggle">Toggle</label>
        <span class="toggle-icon sun-icon">&#9728;</span> <span class="toggle-icon moon-icon">&#9790;</span> </div>

    <div class="max-w-7xl mx-auto">
        <h1 class="text-4xl font-bold mb-8 text-center">Squad Builder</h1>

        <div id="input-section" class="bg-gray-700/50 p-6 rounded-lg shadow-xl transition-all duration-500">
            <h2 class="text-2xl font-semibold mb-4">1. Paste Sign-up List and Select Size</h2>
            
            <div class="mb-4">
                <label for="participant-count" class="block text-sm font-medium mb-1">Select Total Participants/Groups (Initial):</label>
                <select id="participant-count" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-600 focus:outline-none focus:ring-yellow-500 focus:border-yellow-500 sm:text-sm rounded-md bg-gray-800 text-white">
                    <option value="30">30 Participants (7 Groups)</option>
                    <option value="40">40 Participants (9 Groups)</option>
                    <option value="50">50 Participants (11 Groups)</option>
                </select>
            </div>
            
            <div class="mb-4">
                <label for="signup-list" class="block text-sm font-medium mb-1">Paste Sign-up List Text Below:</label>
                <textarea id="signup-list" rows="10" class="shadow-sm focus:ring-yellow-500 focus:border-yellow-500 block w-full sm:text-sm border-gray-600 rounded-md p-3 bg-gray-800 text-white" placeholder="Example:&#10;Participants (50/50):&#10; Commander (1/1)&#10;└ [SOCK] Dobby (DobbyisFree.2917) (DobbyisFree.2917)&#10; Boon Support (2/4)&#10;└ [SOCK] Hagrid (HagridBoonMaster.1743)&#10;..."></textarea>
            </div>

            <button onclick="processList()" class="w-full kpi-card hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded transition duration-150">
                Generate Squad Grid
            </button>
        </div>

        <div id="grid-section" class="hidden mt-8">
            <h2 class="text-2xl font-semibold mb-4">2. Proposed Squad Composition</h2>

            <div class="mb-4">
                <label for="grid-participant-count" class="block text-sm font-medium mb-1">Adjust Visible Groups:</label>
                <select id="grid-participant-count" onchange="updateGridSize()" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-600 focus:outline-none focus:ring-yellow-500 focus:border-yellow-500 sm:text-sm rounded-md bg-gray-800 text-white">
                    <option value="30">30 Participants (7 Groups)</option>
                    <option value="40">40 Participants (9 Groups)</option>
                    <option value="50">50 Participants (11 Groups)</option>
                </select>
            </div>

            <div id="squad-grid" class="overflow-x-auto">
                </div>
            <button onclick="resetApp()" class="mt-6 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded transition duration-150">
                Reset / Enter New List
            </button>
        </div>

    </div>

    <script>
        // Global variable to store parsed roster for dynamic resizing
        window.currentRoster = null;
        let draggedCell = null; // Global variable to hold the element being dragged
        
        // --- Configuration ---
        const ROLES = {
            'AOE DPS': 'role-aoe-dps',
            'Healer': 'role-healer',
            'Boon Support': 'role-boon-support',
            'DPS': 'role-dps',
            'Main Stabs': 'role-main-stabs',
            'Commander': 'role-commander',
            'Support Spellbreaker': 'role-boon-support' // Maps to Boon Support slot, same color
        };

        const GROUP_CONFIGS = {
            '30': 7, // 7 Groups for 30 participants
            '40': 9, // 9 Groups for 40 participants
            '50': 11 // 11 Groups for 50 participants
        };
        
        // Groups 3 and 5 prioritize Support Spellbreaker
        const SPELLBREAKER_GROUPS = [3, 5];
        
        // List of all possible role classes for stripping purposes
        const ALL_ROLE_CLASSES = ['role-aoe-dps', 'role-healer', 'role-boon-support', 'role-dps', 'role-main-stabs', 'role-commander', 'role-empty'];


        // --- Theme Toggle Logic ---
        function toggleTheme() {
            const isLightMode = document.getElementById('theme-toggle').checked;
            if (isLightMode) {
                document.body.classList.add('light-mode');
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.remove('light-mode');
                localStorage.setItem('theme', 'dark');
            }
        }

        // Apply saved theme on load
        document.addEventListener('DOMContentLoaded', () => {
            if (localStorage.getItem('theme') === 'light') {
                document.getElementById('theme-toggle').checked = true;
            }
            toggleTheme();
        });

        // --- Drag & Drop Functions ---
        function drag(event) {
            // Check if the target is a draggable TD element
            if (event.target.tagName === 'TD' && event.target.getAttribute('draggable') === 'true') {
                draggedCell = event.target;
                // Store a small amount of data to satisfy browser requirements
                event.dataTransfer.setData("text/plain", "drag"); 
            }
        }

        function allowDrop(event) {
            // Check if the drop target is a draggable TD element
            if (event.target.closest('td[draggable="true"]')) {
                event.preventDefault(); 
            }
        }

        function drop(event) {
            event.preventDefault();
            const targetCell = event.target.closest('td[draggable="true"]');
            
            // Check for valid drag/drop
            if (!draggedCell || !targetCell || draggedCell === targetCell) {
                return;
            }

            // --- Rule #2: Do not allow drops into Group 1 (Lobby) ---
            const targetRow = targetCell.parentElement;
            const targetRowIndex = Array.from(targetCell.closest('tbody').children).indexOf(targetRow);
            if (targetRowIndex === 0) { // Index 0 is the Group 1/Lobby row
                return;
            }
            
            // --- FIX: Only swap the inner content, keeping column-based attributes static ---
            
            // Store source content
            const sourceHTML = draggedCell.innerHTML;
            
            // Store target content
            const targetHTML = targetCell.innerHTML;
            
            // 1. Update draggedCell (Source) with Target's content
            draggedCell.innerHTML = targetHTML;
            
            // 2. Update targetCell (Destination) with Source's content
            targetCell.innerHTML = sourceHTML;

            // 3. Update Visual Styles for both cells (handles color and contenteditable)
            // handleCellEdit now reads the correct, static data-role-class from the cell's location
            handleCellEdit(draggedCell);
            handleCellEdit(targetCell);
            
            draggedCell = null; // Reset global drag variable
        }
        
        // --- Core Application Logic ---

        function handleCellEdit(cell) {
            const targetRoleClass = cell.getAttribute('data-role-class');
            const placeholderText = cell.getAttribute('data-placeholder');
            const content = cell.textContent.trim();
            const isPlaceholderContent = content === '' || content === placeholderText;

            // 1. Remove all existing role-specific classes
            cell.classList.remove(...ALL_ROLE_CLASSES);
            cell.classList.remove('opacity-50', 'text-center');

            if (isPlaceholderContent) {
                // 2. If content is empty or placeholder, apply empty styling and reset text
                cell.classList.add('role-empty');
                cell.classList.add('opacity-50', 'text-center');
                cell.textContent = placeholderText;
                cell.setAttribute('contenteditable', 'true');
            } else {
                // 3. If content is a player name, apply the correct target role class for coloring
                cell.classList.add(targetRoleClass);
                // Ensure text is trimmed and clean after editing
                cell.textContent = content;
                // Players should not be editable until they are an empty slot again
                cell.removeAttribute('contenteditable'); 
            }
        }
        
        function parseSignupList(text) {
            // Step 1: Aggressively clean the input text to remove Discord emoji placeholders and non-printing characters.
            let cleanedText = text;
            // 1a. Remove Discord emoji placeholders (:word:) and the space/tab that often follows.
            cleanedText = cleanedText.replace(/:\w+:\s*/g, ' '); 
            // 1b. Replace any zero-width space or similar characters.
            cleanedText = cleanedText.replace(/[\u200B-\u200D\uFEFF]/g, '');
            // 1c. Remove any leading/trailing spaces from the overall block.
            cleanedText = cleanedText.trim();
            
            const lines = cleanedText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const roster = {};
            let currentRole = null;
            
            // Regex to match the role header: e.g., "Commander (1/1)"
            const roleRegex = /^\s*([A-Za-z\s\/&]+)\s*\(\d+\/\d+\):?\s*$/; 
            
            // Regex to capture GW2 account names (Name.1234) inside parentheses globally
            const accountNameRegex = /\(([^)]+\.\d{4})\)/g;

            for (const line of lines) {
                // Check for a new role header
                const roleMatch = line.match(roleRegex);
                if (roleMatch) {
                    currentRole = roleMatch[1].trim();
                    roster[currentRole] = roster[currentRole] || [];
                    continue;
                }

                // Check for a player line (starts with '└' and contains account name)
                if (currentRole && line.startsWith('└')) {
                    const matches = [...line.matchAll(accountNameRegex)];
                    
                    if (matches.length > 0) {
                        // The last matched group (index 1 of the last match) is the account name
                        const accountName = matches[matches.length - 1][1];
                        roster[currentRole].push(accountName);
                    }
                }
            }
            return roster;
        }

        function buildSquadGrid(roster, totalGroups) {
            const gridContainer = document.getElementById('squad-grid');
            gridContainer.innerHTML = ''; // Clear previous grid

            // Deep clone the roster queues for consumption in the grid
            const tempRoster = JSON.parse(JSON.stringify(roster));

            let html = `
                <table class="min-w-full divide-y divide-gray-600 rounded-lg overflow-hidden shadow-2xl">
                    <thead class="bg-gray-800/80">
                        <tr>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium uppercase tracking-wider">
                                Group
                            </th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium uppercase tracking-wider ${ROLES['AOE DPS']}">
                                AOE DPS
                            </th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium uppercase tracking-wider ${ROLES['Healer']}">
                                Healer
                            </th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium uppercase tracking-wider ${ROLES['Boon Support']}">
                                Boon Support
                            </th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium uppercase tracking-wider ${ROLES['DPS']}">
                                DPS
                            </th>
                            <th scope="col" class="px-3 py-3 text-left text-xs font-medium uppercase tracking-wider ${ROLES['Main Stabs']}">
                                Main Stabs
                            </th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-gray-700">
            `;

            // Prepare queues for roles
            const commanderQueue = tempRoster['Commander'] || [];
            
            // MAPPING: Main Healer players go into Healer queue
            const mainHealerQueue = tempRoster['Main Healer'] || [];
            const healerQueue = (tempRoster['Healer'] || []).concat(mainHealerQueue);
            
            // MAPPING: Secondary Support players go into Boon Support queue
            const secondarySupportQueue = tempRoster['Secondary Support'] || [];
            const boonSupportQueue = (tempRoster['Boon Support'] || []).concat(secondarySupportQueue);
            
            const supportSpellbreakerQueue = tempRoster['Support Spellbreaker'] || [];
            const dpsQueue = tempRoster['DPS'] || [];
            
            // MAPPING: Boon Strips & Pulls players go into AOE DPS pool
            const boonStripsAndPullsQueue = tempRoster['Boon Strips & Pulls'] || [];
            
            // Merge all AOE DPS types and Boon Strips & Pulls into a single pool
            const aoeDpsQueue = Object.keys(tempRoster)
                .filter(role => role.startsWith('AOE DPS'))
                .flatMap(role => tempRoster[role])
                .concat(boonStripsAndPullsQueue);

            const mainStabsQueue = tempRoster['Main Stabs'] || [];

            // Helper to dequeue a player or provide placeholder
            const getNextPlayer = (queue) => queue.shift() || '... EMPTY ...';
            
            // List of role classes for Group 1 reference
            const roleClasses = [ROLES['AOE DPS'], ROLES['Healer'], ROLES['Boon Support'], ROLES['DPS'], ROLES['Main Stabs']];
            const placeholderEmpty = '... EMPTY ...';
            const placeholderLobby = 'Lobby';
            
            // Common drag/drop attributes
            const dragDropAttr = ' draggable="true" ondragstart="drag(event)" ondragover="allowDrop(event)" ondrop="drop(event)"';

            // Loop for the required number of groups
            for (let i = 1; i <= totalGroups; i++) {
                let rowHtml = `<tr class="bg-gray-700/50 hover:bg-gray-600/50 transition-colors duration-150">`;

                // 1. Group Label (Not draggable, not a drop target)
                rowHtml += `<td class="px-3 py-2 whitespace-nowrap font-medium">Group ${i}</td>`;

                if (i === 1) {
                    // Group 1: Lobby (5 cells)
                    for (let j = 0; j < 5; j++) {
                        const targetRoleClass = roleClasses[j]; 
                        // Note: Group 1 cells are *always* empty/placeholder, so they are always given the empty styling.
                        // The onblur handler will ensure the cell updates its style correctly if a name is entered.
                        rowHtml += `<td class="px-3 py-2 whitespace-nowrap role-empty opacity-50 text-center" 
                                    contenteditable="true" 
                                    title="Lobby"
                                    data-role-class="${targetRoleClass}"
                                    data-placeholder="${placeholderLobby}"
                                    ${dragDropAttr}
                                    onblur="handleCellEdit(this)">
                                    ${placeholderLobby}
                                    </td>`;
                    }
                } else if (i === 2) {
                    // Group 2: Commander (in AOE DPS column), Healer, Boon Support, DPS, Main Stabs
                    
                    const slots = [];
                    
                    // Slot 1: Commander (uses role-commander class, but is in the AOE DPS column)
                    const commanderPlayer = getNextPlayer(commanderQueue);
                    // This slot's style is commander color, even though it's the first column
                    slots.push({ player: commanderPlayer, roleClass: ROLES['Commander'], roleName: 'Commander', placeholder: placeholderEmpty });

                    // Remaining Slots are standard
                    slots.push({ player: getNextPlayer(healerQueue), roleClass: ROLES['Healer'], roleName: 'Healer', placeholder: placeholderEmpty });
                    slots.push({ player: getNextPlayer(boonSupportQueue), roleClass: ROLES['Boon Support'], roleName: 'Boon Support', placeholder: placeholderEmpty });
                    slots.push({ player: getNextPlayer(dpsQueue), roleClass: ROLES['DPS'], roleName: 'DPS', placeholder: placeholderEmpty });
                    slots.push({ player: getNextPlayer(mainStabsQueue), roleClass: ROLES['Main Stabs'], roleName: 'Main Stabs', placeholder: placeholderEmpty });

                    slots.forEach(slot => {
                        const isPlayer = !slot.player.includes('EMPTY');
                        const emptyClass = isPlayer ? slot.roleClass : 'role-empty';
                        const targetRoleClass = slot.roleClass; 
                        
                        // Only make initially empty slots editable
                        const editableAttr = isPlayer 
                            ? ''
                            : ` contenteditable="true" onblur="handleCellEdit(this)"`;

                        const roleSpecificClasses = isPlayer ? '' : ' opacity-50 text-center';

                        rowHtml += `<td class="px-3 py-2 whitespace-nowrap font-semibold ${emptyClass}${roleSpecificClasses}" 
                                        title="${slot.roleName}"
                                        data-role-class="${targetRoleClass}"
                                        data-placeholder="${slot.placeholder}"
                                        ${editableAttr}
                                        ${dragDropAttr}>
                                        ${slot.player}
                                    </td>`;
                    });

                } else {
                    // Groups 3+ (Standard or Spellbreaker variation)
                    
                    const slots = [];
                    
                    // Slot 1: AOE DPS
                    slots.push({ player: getNextPlayer(aoeDpsQueue), roleClass: ROLES['AOE DPS'], roleName: 'AOE DPS', placeholder: placeholderEmpty });

                    // Slot 2: Healer
                    slots.push({ player: getNextPlayer(healerQueue), roleClass: ROLES['Healer'], roleName: 'Healer', placeholder: placeholderEmpty });

                    // Slot 3: Boon Support OR Support Spellbreaker
                    let player;
                    let roleName;
                    let roleClass = ROLES['Boon Support']; 

                    if (SPELLBREAKER_GROUPS.includes(i) && supportSpellbreakerQueue.length > 0) {
                        player = getNextPlayer(supportSpellbreakerQueue);
                        roleName = 'Support Spellbreaker (Boon Support Slot)';
                    } else {
                        player = getNextPlayer(boonSupportQueue);
                        roleName = 'Boon Support';
                    }
                    slots.push({ player, roleClass, roleName, placeholder: placeholderEmpty });

                    // Slot 4: DPS
                    slots.push({ player: getNextPlayer(dpsQueue), roleClass: ROLES['DPS'], roleName: 'DPS', placeholder: placeholderEmpty });

                    // Slot 5: Main Stabs
                    slots.push({ player: getNextPlayer(mainStabsQueue), roleClass: ROLES['Main Stabs'], roleName: 'Main Stabs', placeholder: placeholderEmpty });


                    slots.forEach(slot => {
                        const isPlayer = !slot.player.includes('EMPTY');
                        const emptyClass = isPlayer ? slot.roleClass : 'role-empty';
                        const targetRoleClass = slot.roleClass; 
                        
                        const editableAttr = isPlayer 
                            ? '' 
                            : ` contenteditable="true" onblur="handleCellEdit(this)"`;
                        const roleSpecificClasses = isPlayer ? '' : ' opacity-50 text-center';

                        rowHtml += `<td class="px-3 py-2 whitespace-nowrap font-semibold ${emptyClass}${roleSpecificClasses}" 
                                        title="${slot.roleName}"
                                        data-role-class="${targetRoleClass}"
                                        data-placeholder="${slot.placeholder}"
                                        ${editableAttr}
                                        ${dragDropAttr}>
                                        ${slot.player}
                                    </td>`;
                    });
                }

                rowHtml += `</tr>`;
                html += rowHtml;
            }

            html += `
                    </tbody>
                </table>
            `;
            gridContainer.innerHTML = html;
        }

        function processList() {
            const signupText = document.getElementById('signup-list').value;
            const selectedCount = document.getElementById('participant-count').value;

            if (!signupText.trim()) {
                alert('Please paste the sign-up list.');
                return;
            }

            const roster = parseSignupList(signupText);
            
            // Store roster globally for resizing functionality
            window.currentRoster = roster;

            const totalGroups = GROUP_CONFIGS[selectedCount];

            // Synchronize the resizing dropdown with the initial selection
            const gridCountSelect = document.getElementById('grid-participant-count');
            if (gridCountSelect) {
                gridCountSelect.value = selectedCount;
            }
            
            buildSquadGrid(roster, totalGroups);

            // Hide input, show grid
            document.getElementById('input-section').classList.add('hidden');
            document.getElementById('grid-section').classList.remove('hidden');
        }

        function updateGridSize() {
            if (!window.currentRoster) return; // Roster must be parsed first

            const selectedCount = document.getElementById('grid-participant-count').value;
            const totalGroups = GROUP_CONFIGS[selectedCount];
            
            // Re-run the grid builder with the stored roster and new group count
            buildSquadGrid(window.currentRoster, totalGroups);
        }

        function resetApp() {
            document.getElementById('signup-list').value = '';
            window.currentRoster = null;
            draggedCell = null;
            document.getElementById('grid-section').classList.add('hidden');
            document.getElementById('input-section').classList.remove('hidden');
            document.getElementById('squad-grid').innerHTML = '';
        }

    </script>
</body>
</html>